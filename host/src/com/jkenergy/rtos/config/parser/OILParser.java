/* Generated By:JavaCC: Do not edit this line. OILParser.java */
package com.jkenergy.rtos.config.parser;

import com.jkenergy.rtos.config.Problem;
import com.jkenergy.rtos.config.oilmodel.*;
import java.math.*;
import java.util.*;

@SuppressWarnings("unchecked")  // prevent Java 5.0 Compiler warnings for generics
  public class OILParser implements OILParserConstants {

        // Keep a cache of a token, used when reporting ParseExceptions after token has been consumed
        private Token cachedToken;

    // Run the parser
    public static void main ( String args [ ] ) {

      OILParser parser ;

      if(args.length == 0){
        System.out.println("OIL Parser Version 0.2Alpha:  Reading from standard input . . .");
        parser = new OILParser(System.in);
      }
      else if(args.length == 1){
        System.out.println("OIL Parser Version 0.2Alpha:  Reading from file " + args[0] + " . . ." );
      try {
        parser = new OILParser(new java.io.FileInputStream(args[0]));
      }
      catch(java.io.FileNotFoundException e){
        System.out.println("OIL Parser Version 0.2:  File " + args[0] + " not found.");
        return ;
        }
      }
      else {
        System.out.println("OIL Parser Version 0.2Alpha:  Usage is one of:");
        System.out.println("         java OILParser < inputfile");
        System.out.println("OR");
        System.out.println("         java OILParser inputfile");
        return ;
      }
      try {
        OILDefinition model=new OILDefinition();

        parser.OILDefinition(model,false);              // call root non-terminal, passing OILDefinition model to be populated

        System.out.println("OIL Parser Version 0.2Alpha:  OIL definition syntax check completed successfully.");

        // Do semantic check of the model
        List problems=new ArrayList();

        model.doModelCheck(problems,true);

        if ( problems.size()>0 ) {

                System.out.println("OIL Parser Version 0.2Alpha:  Semantic problems detected.");

                Iterator iter=problems.iterator();

                while ( iter.hasNext() ) {
                        Problem next = (Problem)iter.next();

                        System.out.println(next.getMessage());
                }
        }
        else
                System.out.println("OIL Parser Version 0.2Alpha:  OIL definition parsed successfully.");
      }
      catch(ParseException e){
        System.out.println("OIL Parser Version 0.2Alpha:  Encountered errors during parse.");
        System.out.println(e.getMessage());
      }
    }


   /* 
    * Creates a ParseException using the given message and given token
    */
   private static ParseException generateParseExceptionWithToken(String msg,Token token) {

                ParseException theException = new ParseException(msg);

                // Setup the currentToken member of the ParseException (stores line no. etc.)
                theException.currentToken=token;

                return theException;
   }

   /* 
    * Creates a ParseException using the given message and the cachedToken token
    */
   private ParseException generateParseExceptionUsingCachedToken(String msg) {

                return generateParseExceptionWithToken(msg,cachedToken);
   }

   /* 
    * Creates a ParseException using the given message and the current token
    */
   private ParseException generateParseException(String msg) {

                return generateParseExceptionWithToken(msg,token);
   }

   // Stores the current token in the cachedToken attribute, allows processed tokens to be used to
   // generate ParseExceptions
   private void cacheToken() {
                cachedToken=token;
   }

   /**
    * Performs a parse using the stream specified during construction. The given model is populated
    * during the parse process. 
    *
    * @param model the OILDefinition model populated by the parsed input    
    */
   public void doParse(OILDefinition model) throws ParseException {

                // Pass false so that IMPLEMENTATION not ignored
                OILDefinition(model,false);             // call root non-terminal, passing OILDefinition model to be populated
   }

   /**
    * Performs a parse using the stream specified during construction. The given model is populated
    * during the parse process.The contents of the IMPLEMENTATION section are parsed but not included
    * within the generated OILDefinition model, thus allowing a predefined implementation
    * to be placed within the model prior to the parse.
    *
    * @param model the OILDefinition model populated by the parsed input    
    */
   public void doApplicationParse(OILDefinition model) throws ParseException {

                // Pass true so that IMPLEMENTATION parsed but not placed in OILModel
                OILDefinition(model,true);              // call root non-terminal, passing OILDefinition model to be populated
   }

  final public void OILDefinition(OILDefinition definition,boolean ignoreImplementation) throws ParseException {
    OILVersion(definition);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLEMENTATION:
      ImplementationDefinition(definition,ignoreImplementation);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CPU:
      ApplicationDefinition(definition);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    jj_consume_token(0);
  }

  final public void OILVersion(OILDefinition definition) throws ParseException {
    jj_consume_token(OIL_VERSION);
    jj_consume_token(EQUALS);
    Version();
    Description();
    jj_consume_token(SEMICOLON);
  }

  final public void Version() throws ParseException {
    String();
  }

  final public void ImplementationDefinition(OILDefinition definition,boolean ignoreImplementation) throws ParseException {
        String name,desc;
        ImplementationDefinition implDef;
    jj_consume_token(IMPLEMENTATION);
    name = Name();
                                      implDef = new ImplementationDefinition(name,token.beginLine);
    jj_consume_token(LBRACE);
    ImplementationSpecList(implDef);
    jj_consume_token(RBRACE);
    desc = Description();
    jj_consume_token(SEMICOLON);
                implDef.setDescription(desc);

                // If IMPLEMENTATION is not being ignored then inform OILDefinition of the new ImplementationDefinition
                if ( !ignoreImplementation )
                        definition.setImplDef(implDef);
  }

  final public void ImplementationSpecList(ImplementationDefinition implDef) throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OS:
      case TASK:
      case COUNTER:
      case ALARM:
      case RESOURCE:
      case EVENT:
      case ISR:
      case MESSAGE:
      case COM:
      case APPMODE:
      case NM:
      case IPDU:
      case APPLICATION:
      case SCHEDULETABLE:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      ImplementationSpec(implDef);
    }
  }

  final public void ImplementationSpec(ImplementationDefinition implDef) throws ParseException {
        ObjectKind objType;
        ObjectTypeDefinition objTypeDef;
        String desc;
    objType = Object();
                          objTypeDef=implDef.getObjectTypeDefinition(objType); objTypeDef.setLineNo(token.beginLine);
    jj_consume_token(LBRACE);
    ImplementationList(objTypeDef);
    jj_consume_token(RBRACE);
    desc = Description();
    jj_consume_token(SEMICOLON);
         objTypeDef.setDescription(desc);
  }

  final public ObjectKind Object() throws ParseException {
        ObjectKind objType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OS:
      jj_consume_token(OS);
                objType=ObjectKind.OS_LITERAL;
      break;
    case TASK:
      jj_consume_token(TASK);
                  objType=ObjectKind.TASK_LITERAL;
      break;
    case COUNTER:
      jj_consume_token(COUNTER);
                     objType=ObjectKind.COUNTER_LITERAL;
      break;
    case ALARM:
      jj_consume_token(ALARM);
                   objType=ObjectKind.ALARM_LITERAL;
      break;
    case RESOURCE:
      jj_consume_token(RESOURCE);
                      objType=ObjectKind.RESOURCE_LITERAL;
      break;
    case EVENT:
      jj_consume_token(EVENT);
                   objType=ObjectKind.EVENT_LITERAL;
      break;
    case ISR:
      jj_consume_token(ISR);
                 objType=ObjectKind.ISR_LITERAL;
      break;
    case MESSAGE:
      jj_consume_token(MESSAGE);
                     objType=ObjectKind.MESSAGE_LITERAL;
      break;
    case COM:
      jj_consume_token(COM);
                 objType=ObjectKind.COM_LITERAL;
      break;
    case NM:
      jj_consume_token(NM);
                objType=ObjectKind.NM_LITERAL;
      break;
    case APPMODE:
      jj_consume_token(APPMODE);
                     objType=ObjectKind.APPMODE_LITERAL;
      break;
    case IPDU:
      jj_consume_token(IPDU);
                  objType=ObjectKind.IPDU_LITERAL;
      break;
    case APPLICATION:
      jj_consume_token(APPLICATION);
                         objType=ObjectKind.APPLICATION_LITERAL;
      break;
    case SCHEDULETABLE:
      jj_consume_token(SCHEDULETABLE);
                           objType=ObjectKind.SCHEDULETABLE_LITERAL;
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return objType;}
    throw new Error("Missing return statement in function");
  }

  final public String ObjectLiteral() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OS:
      t = jj_consume_token(OS);
      break;
    case TASK:
      t = jj_consume_token(TASK);
      break;
    case COUNTER:
      t = jj_consume_token(COUNTER);
      break;
    case ALARM:
      t = jj_consume_token(ALARM);
      break;
    case RESOURCE:
      t = jj_consume_token(RESOURCE);
      break;
    case EVENT:
      t = jj_consume_token(EVENT);
      break;
    case ISR:
      t = jj_consume_token(ISR);
      break;
    case MESSAGE:
      t = jj_consume_token(MESSAGE);
      break;
    case COM:
      t = jj_consume_token(COM);
      break;
    case NM:
      t = jj_consume_token(NM);
      break;
    case APPMODE:
      t = jj_consume_token(APPMODE);
      break;
    case IPDU:
      t = jj_consume_token(IPDU);
      break;
    case APPLICATION:
      t = jj_consume_token(APPLICATION);
      break;
    case SCHEDULETABLE:
      t = jj_consume_token(SCHEDULETABLE);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public void ImplementationList(ObjectTypeDefinition objTypeDef) throws ParseException {
        FeatureDefinition featureDef;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OS_TYPE:
      case TASK_TYPE:
      case COUNTER_TYPE:
      case ALARM_TYPE:
      case RESOURCE_TYPE:
      case EVENT_TYPE:
      case ISR_TYPE:
      case MESSAGE_TYPE:
      case COM_TYPE:
      case APPMODE_TYPE:
      case NM_TYPE:
      case IPDU_TYPE:
      case APPLICATION_TYPE:
      case SCHEDULETABLE_TYPE:
      case UINT32:
      case INT32:
      case UINT64:
      case INT64:
      case FLOAT:
      case ENUM:
      case STRING:
      case BOOLEAN:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      featureDef = ImplementationDef();
                if ( objTypeDef.addFeature(featureDef)==false )
                        {if (true) throw generateParseExceptionUsingCachedToken("Attempt redefine existing Parameter '"+featureDef.getName()+"'");}
    }
  }

  final public FeatureDefinition ImplementationDef() throws ParseException {
        FeatureDefinition featureDef;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UINT32:
    case INT32:
    case UINT64:
    case INT64:
    case FLOAT:
    case ENUM:
    case STRING:
    case BOOLEAN:
      featureDef = ImplAttrDef();
      break;
    case OS_TYPE:
    case TASK_TYPE:
    case COUNTER_TYPE:
    case ALARM_TYPE:
    case RESOURCE_TYPE:
    case EVENT_TYPE:
    case ISR_TYPE:
    case MESSAGE_TYPE:
    case COM_TYPE:
    case APPMODE_TYPE:
    case NM_TYPE:
    case IPDU_TYPE:
    case APPLICATION_TYPE:
    case SCHEDULETABLE_TYPE:
      featureDef = ImplRefDef();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return featureDef;}
    throw new Error("Missing return statement in function");
  }

  final public AttributeDefinition ImplAttrDef() throws ParseException {
        String name,desc;
        AttributeDefinition attribDef;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UINT32:
    case INT32:
    case UINT64:
    case INT64:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UINT32:
        jj_consume_token(UINT32);
                                    attribDef=new IntegerAttributeDef(true,32,token.beginLine);
        break;
      case INT32:
        jj_consume_token(INT32);
                                   attribDef=new IntegerAttributeDef(false,32,token.beginLine);
        break;
      case UINT64:
        jj_consume_token(UINT64);
                                    attribDef=new IntegerAttributeDef(true,64,token.beginLine);
        break;
      case INT64:
        jj_consume_token(INT64);
                                   attribDef=new IntegerAttributeDef(false,64,token.beginLine);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      AutoSpecifier(attribDef);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        NumberRange((IntegerAttributeDef)attribDef);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      name = AttributeName();
                                                                                                                       cacheToken();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        MultipleSpecifier(attribDef);
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        DefaultNumber((IntegerAttributeDef)attribDef);
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
      break;
    case FLOAT:
      jj_consume_token(FLOAT);
                            attribDef=new FloatAttributeDef(token.beginLine);
      AutoSpecifier(attribDef);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        FloatRange((FloatAttributeDef)attribDef);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
      name = AttributeName();
                                                                                                                                                                         cacheToken();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        MultipleSpecifier(attribDef);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        DefaultFloat((FloatAttributeDef)attribDef);
        break;
      default:
        jj_la1[13] = jj_gen;
        ;
      }
      break;
    case ENUM:
      jj_consume_token(ENUM);
                           attribDef=new EnumerationAttributeDef(token.beginLine);
      AutoSpecifier(attribDef);
      Enumeration((EnumerationAttributeDef)attribDef);
      name = AttributeName();
                                                                                                                                                                                   cacheToken();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        MultipleSpecifier(attribDef);
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        DefaultName((EnumerationAttributeDef)attribDef);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      break;
    case STRING:
      jj_consume_token(STRING);
                             attribDef=new StringAttributeDef(token.beginLine);
      AutoSpecifier(attribDef);
      name = AttributeName();
                                                                                                                                cacheToken();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        MultipleSpecifier(attribDef);
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        DefaultString((StringAttributeDef)attribDef);
        break;
      default:
        jj_la1[17] = jj_gen;
        ;
      }
      break;
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
                              attribDef=new BoolAttributeDef(token.beginLine);
      AutoSpecifier(attribDef);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        BoolValues((BoolAttributeDef)attribDef);
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      name = AttributeName();
                                                                                                                                                                         cacheToken();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACKET:
        MultipleSpecifier(attribDef);
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQUALS:
        DefaultBool((BoolAttributeDef)attribDef);
        break;
      default:
        jj_la1[20] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    desc = Description();
    jj_consume_token(SEMICOLON);
                attribDef.setName(name);
                attribDef.setDescription(desc);

                {if (true) return attribDef;}
    throw new Error("Missing return statement in function");
  }

  final public void ImplParameterList(ParameterizedAttributeDef paramDef) throws ParseException {
    jj_consume_token(LBRACE);
    ImplDefList(paramDef);
    jj_consume_token(RBRACE);
  }

  final public void ImplDefList(ParameterizedAttributeDef paramDef) throws ParseException {
        FeatureDefinition featureDef;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OS_TYPE:
      case TASK_TYPE:
      case COUNTER_TYPE:
      case ALARM_TYPE:
      case RESOURCE_TYPE:
      case EVENT_TYPE:
      case ISR_TYPE:
      case MESSAGE_TYPE:
      case COM_TYPE:
      case APPMODE_TYPE:
      case NM_TYPE:
      case IPDU_TYPE:
      case APPLICATION_TYPE:
      case SCHEDULETABLE_TYPE:
      case UINT32:
      case INT32:
      case UINT64:
      case INT64:
      case FLOAT:
      case ENUM:
      case STRING:
      case BOOLEAN:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_3;
      }
      featureDef = ImplementationDef();
                if ( paramDef.addSubFeature(featureDef)==false )
                        {if (true) throw generateParseExceptionUsingCachedToken("Attempt redefine existing Parameter '"+featureDef.getName()+"'");}
    }
  }

  final public void AutoSpecifier(AttributeDefinition attribDef) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH_AUTO:
      jj_consume_token(WITH_AUTO);
                      attribDef.isWithAuto(true);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
  }

  final public void NumberRange(IntegerAttributeDef attribDef) throws ParseException {
        BigInteger minValue,maxValue;
    jj_consume_token(LBRACKET);
    minValue = Number();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RANGE:
      jj_consume_token(RANGE);
      maxValue = Number();
                                                        attribDef.setRange(minValue,maxValue);
      break;
    default:
      jj_la1[24] = jj_gen;
                                                                                                   attribDef.addListValue(minValue);
      NumberList(attribDef);
    }
    jj_consume_token(RBRACKET);
  }

  final public void NumberList(IntegerAttributeDef attribDef) throws ParseException {
        BigInteger value;
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_4;
      }
      jj_consume_token(COMMA);
      value = Number();
                             attribDef.addListValue(value);
    }
  }

  final public void DefaultNumber(IntegerAttributeDef attribDef) throws ParseException {
        BigInteger value;
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER_LITERAL:
      value = Number();
                             attribDef.setDefaultValue(value);
      break;
    case NO_DEFAULT:
      jj_consume_token(NO_DEFAULT);
      break;
    case AUTO:
      jj_consume_token(AUTO);
                                                                                     attribDef.isAuto(true);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public String Description() throws ParseException {
                         String s;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      s = String();
                          {if (true) return s;}
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
         {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public void FloatRange(FloatAttributeDef attribDef) throws ParseException {
        BigDecimal minValue,maxValue;
    jj_consume_token(LBRACKET);
    minValue = Float();
    jj_consume_token(RANGE);
    maxValue = Float();
    jj_consume_token(RBRACKET);
                                                        attribDef.setRange(minValue,maxValue);
  }

  final public void DefaultFloat(FloatAttributeDef attribDef) throws ParseException {
        BigDecimal value;
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT_LITERAL:
      value = Float();
                            attribDef.setDefaultValue(value);
      break;
    case NO_DEFAULT:
      jj_consume_token(NO_DEFAULT);
      break;
    case AUTO:
      jj_consume_token(AUTO);
                                                                                    attribDef.isAuto(true);
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Enumeration(EnumerationAttributeDef attribDef) throws ParseException {
    jj_consume_token(LBRACKET);
    EnumeratorList(attribDef);
    jj_consume_token(RBRACKET);
  }

  final public void EnumeratorList(EnumerationAttributeDef attribDef) throws ParseException {
    Enumerator(attribDef);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      Enumerator(attribDef);
    }
  }

  final public void Enumerator(EnumerationAttributeDef attribDef) throws ParseException {
        EnumeratorDef enumDef;
        String name,desc;
    name = Name();
                     enumDef=new EnumeratorDef(name,token.beginLine); cacheToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ImplParameterList(enumDef);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    desc = Description();
                enumDef.setDescription(desc);

                if ( attribDef.addEnumerator(enumDef)==false )
                        {if (true) throw generateParseExceptionUsingCachedToken("Attempt to define a duplicate enumerator value '"+name+"'");}
  }

  final public void BoolValues(BoolAttributeDef attribDef) throws ParseException {
        String desc;
        BoolValueDef trueValue,falseValue;
    jj_consume_token(LBRACKET);
    jj_consume_token(TRUE);
                    trueValue=attribDef.getTrueValue(); trueValue.setLineNo(token.beginLine);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ImplParameterList(trueValue);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    desc = Description();
                                                                                                                                                  trueValue.setDescription(desc);
    jj_consume_token(COMMA);
    jj_consume_token(FALSE);
                     falseValue=attribDef.getFalseValue(); falseValue.setLineNo(token.beginLine);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ImplParameterList(falseValue);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    desc = Description();
                                                                                                                                                       falseValue.setDescription(desc);
    jj_consume_token(RBRACKET);
  }

  final public void DefaultName(EnumerationAttributeDef attribDef) throws ParseException {
        String value;
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NAME:
      value = Name();
                           attribDef.setDefaultValue(value);
      break;
    case NO_DEFAULT:
      jj_consume_token(NO_DEFAULT);
      break;
    case AUTO:
      jj_consume_token(AUTO);
                                                                                   attribDef.isAuto(true);
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DefaultString(StringAttributeDef attribDef) throws ParseException {
        String value;
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      value = String();
                             attribDef.setDefaultValue(value);
      break;
    case NO_DEFAULT:
      jj_consume_token(NO_DEFAULT);
      break;
    case AUTO:
      jj_consume_token(AUTO);
                                                                                     attribDef.isAuto(true);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DefaultBool(BoolAttributeDef attribDef) throws ParseException {
        boolean value;
    jj_consume_token(EQUALS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
    case FALSE:
      value = Boolean();
                              attribDef.setDefaultValue(value);
      break;
    case NO_DEFAULT:
      jj_consume_token(NO_DEFAULT);
      break;
    case AUTO:
      jj_consume_token(AUTO);
                                                                                      attribDef.isAuto(true);
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public ReferenceDef ImplRefDef() throws ParseException {
        ObjectKind objType;
        String name,desc;
        ReferenceDef refDef;
    objType = ObjectRefType();
    name = ReferenceName();
                                                      refDef=new ReferenceDef(objType,name,token.beginLine); cacheToken();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      MultipleSpecifier(refDef);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    desc = Description();
    jj_consume_token(SEMICOLON);
                refDef.setDescription(desc);

                {if (true) return refDef;}
    throw new Error("Missing return statement in function");
  }

  final public ObjectKind ObjectRefType() throws ParseException {
        ObjectKind objType;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OS_TYPE:
      jj_consume_token(OS_TYPE);
                     objType=ObjectKind.OS_LITERAL;
      break;
    case TASK_TYPE:
      jj_consume_token(TASK_TYPE);
                       objType=ObjectKind.TASK_LITERAL;
      break;
    case COUNTER_TYPE:
      jj_consume_token(COUNTER_TYPE);
                          objType=ObjectKind.COUNTER_LITERAL;
      break;
    case ALARM_TYPE:
      jj_consume_token(ALARM_TYPE);
                        objType=ObjectKind.ALARM_LITERAL;
      break;
    case RESOURCE_TYPE:
      jj_consume_token(RESOURCE_TYPE);
                           objType=ObjectKind.RESOURCE_LITERAL;
      break;
    case EVENT_TYPE:
      jj_consume_token(EVENT_TYPE);
                        objType=ObjectKind.EVENT_LITERAL;
      break;
    case ISR_TYPE:
      jj_consume_token(ISR_TYPE);
                      objType=ObjectKind.ISR_LITERAL;
      break;
    case MESSAGE_TYPE:
      jj_consume_token(MESSAGE_TYPE);
                          objType=ObjectKind.MESSAGE_LITERAL;
      break;
    case COM_TYPE:
      jj_consume_token(COM_TYPE);
                      objType=ObjectKind.COM_LITERAL;
      break;
    case NM_TYPE:
      jj_consume_token(NM_TYPE);
                     objType=ObjectKind.NM_LITERAL;
      break;
    case APPMODE_TYPE:
      jj_consume_token(APPMODE_TYPE);
                          objType=ObjectKind.APPMODE_LITERAL;
      break;
    case IPDU_TYPE:
      jj_consume_token(IPDU_TYPE);
                       objType=ObjectKind.IPDU_LITERAL;
      break;
    case APPLICATION_TYPE:
      jj_consume_token(APPLICATION_TYPE);
                              objType=ObjectKind.APPLICATION_LITERAL;
      break;
    case SCHEDULETABLE_TYPE:
      jj_consume_token(SCHEDULETABLE_TYPE);
                                objType=ObjectKind.SCHEDULETABLE_LITERAL;
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return objType;}
    throw new Error("Missing return statement in function");
  }

  final public String ReferenceName() throws ParseException {
        String name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NAME:
      name = Name();
      break;
    case OS:
    case TASK:
    case COUNTER:
    case ALARM:
    case RESOURCE:
    case EVENT:
    case ISR:
    case MESSAGE:
    case COM:
    case APPMODE:
    case NM:
    case IPDU:
    case APPLICATION:
    case SCHEDULETABLE:
      name = ObjectLiteral();
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public void MultipleSpecifier(FeatureDefinition featureDef) throws ParseException {
    jj_consume_token(LBRACKET);
    jj_consume_token(RBRACKET);
          featureDef.isMultiple(true);
  }

  final public void ApplicationDefinition(OILDefinition definition) throws ParseException {
        ApplicationDefinition appDef;
        String name,desc;
    jj_consume_token(CPU);
    name = Name();
                           appDef=new ApplicationDefinition(definition,name,token.beginLine);
    jj_consume_token(LBRACE);
    ObjectDefinitionList(appDef);
    jj_consume_token(RBRACE);
    desc = Description();
    jj_consume_token(SEMICOLON);
                appDef.setDescription(desc);

                definition.setApplicationDef(appDef);   // inform OILDefinition of the new ApplicationDefinition

  }

  final public void ObjectDefinitionList(ApplicationDefinition appDef) throws ParseException {
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OS:
      case TASK:
      case COUNTER:
      case ALARM:
      case RESOURCE:
      case EVENT:
      case ISR:
      case MESSAGE:
      case COM:
      case APPMODE:
      case NM:
      case IPDU:
      case APPLICATION:
      case SCHEDULETABLE:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_6;
      }
      ObjectDefinition(appDef);
    }
  }

  final public void ObjectDefinition(ApplicationDefinition appDef) throws ParseException {
        String desc;
        ObjectDefinition obj;
    obj = ObjectName(appDef);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      jj_consume_token(LBRACE);
      ParameterList(obj);
      jj_consume_token(RBRACE);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    desc = Description();
    jj_consume_token(SEMICOLON);
                obj.setDescription(desc);
  }

  final public ObjectDefinition ObjectName(ApplicationDefinition appDef) throws ParseException {
        ObjectKind objType;
        String name;
    objType = Object();
    name = Name();
                // Attempt to get an existing ObjectDefinition with the specified name
                // This is done since the splitting of object definitions is allowed (providing they refer to same object type)
                ObjectDefinition obj = appDef.findNamedObjectDefinition(name);

                if ( obj==null ) {
                        // An ObjectDefinition with the given name does not exist, so create one and add to ApplicationDefinition
                        obj=new ObjectDefinition(appDef,objType,name,token.beginLine);
                        appDef.addObjectDefinition(obj);
                }
                else {
                        // An ObjectDefinition with the given name does exist, so ensure that it represents same object type
                        if ( !objType.equals(obj.getObjectType()) )
                                {if (true) throw generateParseException("Attempt to define an Object using an existing name '"+name+"'");}
                }

                {if (true) return obj;}
    throw new Error("Missing return statement in function");
  }

  final public void ParameterList(ObjectDefinition obj) throws ParseException {
        Parameter param;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OS:
      case TASK:
      case COUNTER:
      case ALARM:
      case RESOURCE:
      case EVENT:
      case ISR:
      case MESSAGE:
      case COM:
      case APPMODE:
      case NM:
      case IPDU:
      case APPLICATION:
      case SCHEDULETABLE:
      case NAME:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_7;
      }
      param = Parameter(obj);
                               obj.addParameter(param);
    }
  }

  final public void SubParameterList(ParameterizedValue paramValue) throws ParseException {
        Parameter param;
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OS:
      case TASK:
      case COUNTER:
      case ALARM:
      case RESOURCE:
      case EVENT:
      case ISR:
      case MESSAGE:
      case COM:
      case APPMODE:
      case NM:
      case IPDU:
      case APPLICATION:
      case SCHEDULETABLE:
      case NAME:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_8;
      }
      param = Parameter(paramValue);
                                      paramValue.addSubParameter(param);
    }
  }

  final public Parameter Parameter(OILElement owner) throws ParseException {
        String name,desc;
        Parameter param;
    name = AttributeName();
                              param=new Parameter(owner,name,token.beginLine);
    jj_consume_token(EQUALS);
    AttributeValue(param);
    desc = Description();
    jj_consume_token(SEMICOLON);
                param.setDescription(desc);

                {if (true) return param;}
    throw new Error("Missing return statement in function");
  }

  final public String AttributeName() throws ParseException {
        String name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NAME:
      name = Name();
      break;
    case OS:
    case TASK:
    case COUNTER:
    case ALARM:
    case RESOURCE:
    case EVENT:
    case ISR:
    case MESSAGE:
    case COM:
    case APPMODE:
    case NM:
    case IPDU:
    case APPLICATION:
    case SCHEDULETABLE:
      name = ObjectLiteral();
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  final public void AttributeValue(Parameter param) throws ParseException {
        FeatureValue featureVal;
        String strVal;
        boolean boolVal;
        BigInteger intVal;
        BigDecimal floatVal;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AUTO:
      jj_consume_token(AUTO);
                  featureVal=new AutoValue(param,token.beginLine);
      break;
    case STRING_LITERAL:
      strVal = String();
                           featureVal=new StringValue(param,strVal,token.beginLine);
      break;
    case TRUE:
    case FALSE:
      boolVal = Boolean();
                             featureVal=new BooleanValue(param,boolVal,token.beginLine);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        SubParameterList((ParameterizedValue)featureVal);
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[44] = jj_gen;
        ;
      }
      break;
    case NAME:
      strVal = Name();
                         featureVal=new NameValue(param,strVal,token.beginLine);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        jj_consume_token(LBRACE);
        SubParameterList((ParameterizedValue)featureVal);
        jj_consume_token(RBRACE);
        break;
      default:
        jj_la1[45] = jj_gen;
        ;
      }
      break;
    case NUMBER_LITERAL:
      intVal = Number();
                           featureVal=new IntegerValue(param,intVal,token.beginLine);
      break;
    case FLOAT_LITERAL:
      floatVal = Float();
                            featureVal=new FloatValue(param,floatVal,token.beginLine);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         param.setValue(featureVal);
  }

  final public String Name() throws ParseException {
                  Token t;
    t = jj_consume_token(NAME);
          {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public String String() throws ParseException {
                    Token t;
    t = jj_consume_token(STRING_LITERAL);
          String s = t.image;

          // strip leading and trailing quotes
          s = s.substring(1,s.length()-1);

          {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public boolean Boolean() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
      jj_consume_token(FALSE);
                 {if (true) return false;}
      break;
    case TRUE:
      jj_consume_token(TRUE);
                                          {if (true) return true;}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public BigInteger Number() throws ParseException {
        Token t;
        BigInteger value;
    t = jj_consume_token(NUMBER_LITERAL);
                try {
                        String number=t.image;

                        if ( number.startsWith("0x") ) {
                                // parse as base 16 number, stripping 0x from start of the number string
                                value = new BigInteger(number.substring(2),16);
                        }
                        else {
                                // parse as decimal number
                                value = new BigInteger(number);
                        }

                        {if (true) return value;}
                }
                catch (NumberFormatException e) {
                        // throw exception to report syntax error since invalid integer value
                        {if (true) throw generateParseException("Invalid integer number format");}
                }
    throw new Error("Missing return statement in function");
  }

  final public BigDecimal Float() throws ParseException {
        Token t;
        BigDecimal value;
    t = jj_consume_token(FLOAT_LITERAL);
                try {
                        value = new BigDecimal(t.image);
                        {if (true) return value;}
                }
                catch (NumberFormatException e) {
                        // throw exception to report syntax error since invalid float value
                        {if (true) throw generateParseException("Invalid float number format");}
                }
    throw new Error("Missing return statement in function");
  }

  public OILParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[48];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x1fff80,0x1fff80,0x1fff80,0xffe00000,0xffe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe00000,0x1fff80,0x1fff80,0x0,0x1fff80,0x1fff80,0x1fff80,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x40,0x100,0x0,0x0,0x0,0x7f807,0x7f807,0x7800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7f800,0x7f807,0x20,0x0,0x20000000,0x1000018,0x40000000,0x8000018,0x20000000,0x0,0x0,0x0,0x80018,0x400018,0x618,0x0,0x7,0x80000,0x0,0x0,0x80000,0x80000,0x80000,0x0,0x0,0x9480610,0x600,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x1,0x2,0x2,0x1,0x2,0x1,0x2,0x1,0x2,0x2,0x1,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x8,0x8,0x8,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x8,0x8,0x0,0x0,};
   }

  public OILParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public OILParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new OILParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  public OILParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OILParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  public OILParser(OILParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  public void ReInit(OILParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[71];
    for (int i = 0; i < 71; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 48; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 71; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  }
